const express = require("express");
const cors = require("cors")

const ErrorResponse = require("./api/utils/ErrorResponse"); // Classe para representar erros customizados da API
const Logger = require("./api/utils/Logger"); // Utilit√°rio para registrar logs (console/arquivo/etc.)

// Middlewares
const JwtMiddleware = require("./api/middleware/JwtMiddleware"); // Middleware de autentica√ß√£o via JWT

// Roteadores
const CargoRoteador = require("./api/router/CargoRoteador");
const FuncionarioRoteador = require("./api/router/FuncionarioRoteador");

// Middlewares espec√≠ficos das entidades
const CargoMiddleware = require("./api/middleware/CargoMiddleware");
const FuncionarioMiddleware = require("./api/middleware/FuncionarioMiddleware");

// Controllers (controladores das regras de entrada/sa√≠da HTTP)
const CargoControle = require("./api/control/CargoControl");
const FuncionarioControl = require("./api/control/FuncionarioControl");

// Services (camada de regras de neg√≥cio)
const CargoService = require("./api/service/CargoService");
const FuncionarioService = require("./api/service/FuncionarioService");

// DAOs (camada de acesso a dados, comunica√ß√£o com o banco)
const CargoDAO = require("./api/dao/CargoDAO");
const FuncionarioDAO = require("./api/dao/FuncionarioDAO");

// Banco de dados (pool de conex√µes MySQL centralizado)
const MysqlDatabase = require("./api/database/MysqlDatabase");

/**
 * Classe principal do servidor Express.
 * 
 * Responsabilidades:
 * - Configurar middlewares globais (ex: JSON, est√°ticos, autentica√ß√£o).
 * - Inicializar pool de conex√µes com MySQL.
 * - Montar depend√™ncias das camadas (DAO ‚Üí Service ‚Üí Controller ‚Üí Router).
 * - Tratar erros globais com errorHandler.
 * - Subir o servidor Express.
 */
module.exports = class Server {
    // üîí Atributos privados (encapsulamento)
    #porta;
    #app;
    #router;

    #database; // Pool global de conex√µes do MySQL

    #jwtMiddleware; // Middleware de autentica√ß√£o

    #cargoRoteador;
    #cargoMiddleware;
    #cargoControl;
    #cargoService;
    #cargoDAO;


    #funcionarioRoteador;
    #funcionarioMiddleware;
    #funcionarioControl;
    #funcionarioService;
    #funcionarioDAO;

    /**
     * Construtor recebe a porta onde o servidor ser√° iniciado.
     * Caso n√£o seja passada, usa a porta 8080 por padr√£o.
     */
    constructor(porta) {
        console.log("‚¨ÜÔ∏è CargoControl.constructor()");
        this.#porta = process.env.PORT || porta || 8080;
    }

    /**
     * M√©todo de inicializa√ß√£o da aplica√ß√£o.
     * 
     * - Configura o Express (JSON, arquivos est√°ticos).
     * - Cria middlewares globais.
     * - Inicializa pool do banco.
     * - Configura m√≥dulos de Cargo e Funcion√°rio.
     * - Configura tratamento de erros.
     */
    init = async () => {
        console.log("‚¨ÜÔ∏è  Server.init()");
        this.#app = express();
        this.#router = express.Router();
        this.#app.use(express.json()); // Habilita leitura de JSON no corpo da requisi√ß√£o
        this.#app.use(express.static("static")); // Habilita pasta "static" para arquivos p√∫blicos (ex: HTML, JS, CSS)

        //configura√ß√£o de cors significa que qualquer site ou dom√≠nio pode fazer requisi√ß√µes para sua API sem sofre bloquio de cors
        this.#app.use(cors({ origin: "*" }));
        /**
         * cors pode trabalhar com configura√ß√µes complexas, veja exemplo abaixo.
         * this.#app.use(cors({
               origin: ["http://localhost:3000", "https://meusite.com"],
                methods: ["GET", "POST"],
                allowedHeaders: ["Content-Type", "Authorization"]
            }));
         */

        this.#jwtMiddleware = new JwtMiddleware(); // Inicializa middleware JWT

        // üîπ Cria o pool global de conex√µes MySQL
    const dbConfig = {
    host: process.env.MYSQL_ADDON_HOST || "localhost",
    user: process.env.MYSQL_ADDON_USER || "root",
    password: process.env.MYSQL_ADDON_PASSWORD || "",
    database: process.env.MYSQL_ADDON_DB || "gestao_rh",
    port: process.env.MYSQL_ADDON_PORT || 3306,
    waitForConnections: true, 
    connectionLimit: 50,      
    queueLimit: 10            
};

this.#database = new MysqlDatabase(dbConfig);

        // Monta depend√™ncias e rotas de cada m√≥dulo
        this.beforeRouting(); // Middleware executado antes das rotas
        this.setupCargo();
        this.setupFuncionario();
        this.setupErrorMiddleware(); // Configura tratamento global de erros
    }

    /**
     * Configura√ß√£o do m√≥dulo Cargo.
     * - Cria middleware, DAO, Service e Controller.
     * - Injeta depend√™ncias.
     * - Registra rotas em "/api/v1/cargos".
     */
    setupCargo = () => {
        console.log("‚¨ÜÔ∏è  Server.setupCargo()");

        // üîπ Middleware de valida√ß√£o para Cargo
        // Verifica se os dados recebidos nas requisi√ß√µes est√£o corretos
        // antes de passar para o Controller. Isso mant√©m a l√≥gica de valida√ß√£o
        // separada da l√≥gica de neg√≥cio.
        this.#cargoMiddleware = new CargoMiddleware();

        // üîπ DAO de Cargo
        // Recebe a conex√£o com o banco (pool MysqlDatabase) via inje√ß√£o de depend√™ncia.
        // O DAO n√£o precisa saber como a conex√£o foi criada, apenas usa os m√©todos dispon√≠veis.
        this.#cargoDAO = new CargoDAO(this.#database);

        // üîπ Service de Cargo
        // Recebe o DAO via inje√ß√£o de depend√™ncia.
        // O Service cont√©m a l√≥gica de neg√≥cio da entidade Cargo
        // e n√£o precisa acessar diretamente o banco de dados.
        this.#cargoService = new CargoService(this.#cargoDAO);

        // üîπ Controller de Cargo
        // Recebe o Service via inje√ß√£o de depend√™ncia.
        // O Controller apenas recebe requisi√ß√µes HTTP e delega a execu√ß√£o
        // da l√≥gica de neg√≥cio ao Service.
        this.#cargoControl = new CargoControle(this.#cargoService);

        // üîπ Roteador de Cargo
        // Recebe todas as depend√™ncias necess√°rias:
        // - express Router
        // - jwtMiddleware ‚Üí autentica√ß√£o
        // - cargoMiddleware ‚Üí valida√ß√£o de entrada
        // - cargoControl ‚Üí manipula√ß√£o da l√≥gica de neg√≥cio
        this.#cargoRoteador = new CargoRoteador(
            this.#router,
            this.#jwtMiddleware,
            this.#cargoMiddleware,
            this.#cargoControl
        );

        // üîπ Registro final no Express
        // Todas as rotas da entidade Cargo ficam dispon√≠veis em:
        // http://localhost:PORT/api/v1/cargos
        this.#app.use("/api/v1/cargos", this.#cargoRoteador.createRoutes());
    }

    /**
     * Configura√ß√£o do m√≥dulo Funcion√°rio.
     * - Cria middleware, DAO, Service e Controller.
     * - Injeta depend√™ncias.
     * - Registra rotas em "/api/v1/funcionarios".
     * 
     * Observa√ß√£o: Como Funcion√°rio depende de Cargo, garante que CargoDAO j√° foi instanciado.
     */
    setupFuncionario = () => {
        console.log("‚¨ÜÔ∏è  Server.setupFuncionario");

        // üîπ Middleware de valida√ß√£o para Funcion√°rio
        // Respons√°vel por verificar se os dados recebidos na requisi√ß√£o
        // est√£o corretos antes de chamar a camada de controle.
        this.#funcionarioMiddleware = new FuncionarioMiddleware();

        // üîπ DAO de Funcion√°rio
        // Recebe o pool do banco (MysqlDatabase) via inje√ß√£o de depend√™ncia.
        // Assim, o DAO n√£o conhece os detalhes de como a conex√£o foi criada,
        // apenas sabe usar a inst√¢ncia recebida.
        this.#funcionarioDAO = new FuncionarioDAO(this.#database);

        // üîπ Depend√™ncia cruzada:
        // Como o Funcion√°rio possui v√≠nculo com Cargo (chave estrangeira),
        // o Service de Funcion√°rio precisa acessar tamb√©m o CargoDAO.
        // Caso ainda n√£o tenha sido inicializado, criamos aqui.
        if (!this.#cargoDAO) {
            this.#cargoDAO = new CargoDAO(this.#database);
        }

        // üîπ Service de Funcion√°rio
        // Recebe o DAO de Funcion√°rio e o DAO de Cargo por inje√ß√£o de depend√™ncia.
        // Assim, ele n√£o precisa saber como acessar o banco, apenas chama os m√©todos do DAO.
        // - funcionarioDAO ‚Üí usado para CRUD de Funcion√°rio.
        // - cargoDAO ‚Üí usado para validar/consultar Cargo vinculado.
        this.#funcionarioService = new FuncionarioService(this.#funcionarioDAO, this.#cargoDAO);

        // üîπ Controller de Funcion√°rio
        // Recebe o Service via inje√ß√£o.
        // Assim, o Controller n√£o implementa regras de neg√≥cio,
        // apenas repassa as requisi√ß√µes HTTP para o Service.
        this.#funcionarioControl = new FuncionarioControl(this.#funcionarioService);

        // üîπ Roteador de Funcion√°rio
        // Recebe todas as depend√™ncias necess√°rias:
        // - jwtMiddleware ‚Üí garante autentica√ß√£o.
        // - funcionarioMiddleware ‚Üí garante valida√ß√£o de entrada.
        // - funcionarioControl ‚Üí controla a l√≥gica de entrada/sa√≠da HTTP.
        this.#funcionarioRoteador = new FuncionarioRoteador(
            this.#jwtMiddleware,
            this.#funcionarioMiddleware,
            this.#funcionarioControl
        );

        // üîπ Registro final no Express
        // Todas as rotas de funcion√°rio ficam dispon√≠veis em:
        // http://localhost:PORT/api/v1/funcionarios
        this.#app.use("/api/v1/funcionarios", this.#funcionarioRoteador.createRoutes());
    }
    /**
     * Middleware executado antes de todas as rotas.
     * Aqui serve apenas para logar uma separa√ß√£o no console.
     */
    beforeRouting = () => {
        this.#app.use((req, res, next) => {
            console.log("------------------------------------------------------------------");
            next();
        });
    }

    /**
     * Middleware global de tratamento de erros.
     * - Captura erros lan√ßados em rotas.
     * - Diferencia erros customizados (ErrorResponse) de erros gen√©ricos.
     * - Retorna resposta JSON padronizada.
     */
    setupErrorMiddleware = () => {
        console.log("‚¨ÜÔ∏è  Server.setupErrorHandler")
        this.#app.use((error, request, response, next) => {
            if (error instanceof ErrorResponse) {
                console.log("üü° Server.errorHandler()");
                return response.status(error.httpCode).json({
                    success: false,
                    message: error.message,
                    error: error.error
                });
            }

            // Erro gen√©rico (n√£o tratado especificamente)
            const resposta = {
                success: false,
                message: "Ocorreu um erro interno no servidor",
                data: { stack: error.stack },
                error: { message: error.message || "Erro interno", code: error.code }
            };
            console.error("‚ùå Erro capturado:", resposta);
            Logger.log(resposta);
            response.status(500).json(resposta);
        });
    }

    /**
     * Inicializa o servidor Express na porta configurada.
     * Exibe no console o link do servidor.
     */
    run = () => {
        this.#app.listen(this.#porta, () => {
                console.log(`üöÄ Server rodando em http://localhost:${this.#porta}/Login.html`);
        });
}
}
